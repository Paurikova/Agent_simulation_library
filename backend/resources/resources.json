{
  "include" : {
    "Agent" : "#pragma once\n\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <unordered_map>\n#include <memory>\n\n#include \"types.h\"\n#include \"schedule.h\"\n#include \"petriNet.h\"\n\n/**\n * @brief Represents an agent in the simulation.\n *\n * Agents interact with each other by sending and receiving messages.\n */\nclass Agent {\nprivate:\n    static AgentId_t nextAgentId;\n    AgentId_t id; /**< The unique identifier of the agent. */\n    Agent* parent; /**< The pointer to agent's parent. */\n    std::unordered_map<AgentId_t, Agent*> childs; /**< The map of pointers to agent's childs. */\n    SimTime_t currTime; /**< The current time in the simulation. */\n    std::unique_ptr<std::vector<Message*>> outBox ; /**< Outgoing message queue. */\n    std::unordered_map<ServiceId_t, ExecFunct_t> functionMap; /**< Maps functions to service IDs. */\n    PetriNet* petriNet; /**< Petri net for intelligent agent. */\n    std::unique_ptr<Schedule> schedule ; /**< Schedule for managing agent's tasks. */\n    AgentType agentType; /**< Type of agent. */\n\nprivate:\n    /**\n     * @brief Processes an function.\n     *\n     * @param pServiceId The ID of the service.\n     * @param pSender The ID of the sender.\n     */\n    void process(ServiceId_t pServiceId, AgentId_t pSender);\n\nprotected:\n    /**\n     * @brief Gets the current time in the simulation.\n     *\n     * @return The current time.\n     */\n    SimTime_t getCurrTime() const;\n\n    /**\n     * @brief Sends a message to another agent.\n     *\n     * @param pServiceId The ID of the service.\n     * @param pReceiver The ID of the receiver agent.\n     * @param pTime The time at which the message is sent.\n     * @param pPriority The priority of the message (optional, default is -1).\n     */\n    void sendMessage(ServiceId_t pServiceId, SimTime_t pTime, AgentId_t pReceiver = -1, int pPriority = -1);\n\n    /**\n     * @brief Registers a function to handle a specific service ID.\n     *\n     * @param pServiceId The ID of the service.\n     * @param pFunc The function to be registered.\n     */\n    void registerFunction(ServiceId_t pServiceId, ExecFunct_t pFunc);\n\n    /**\n     * @brief Unregisters a function associated with a specific service ID.\n     *\n     * @param pServiceId The ID of the service.\n     */\n    void unregisterFunction(ServiceId_t pServiceId);\n\npublic:\n    /**\n     * @brief Constructs an Agent object.\n     *\n     * @param pParent The pointer to agent parent.\n     */\n    explicit Agent(Agent* pParent);\n    \n    /**\n     * @brief Set agent type.\n     * @param newAgentType new agent type\n     */\n    void setAgentType(AgentType newAgentType);\n\n    /**\n     * @brief Gets the ID of the agent.\n     *\n     * @return The ID of the agent.\n     */\n    AgentId_t getId() const;\n\n    /**\n     * @brief Receives a message and push it into agent's schedule.\n     *\n     * @param msg pMsg message to be received.\n     */\n    void receiveMessage(Message* pMsg);\n\n    /**\n     * @brief Execution of all actions for a schedule.\n     */\n    void execute();\n\n    /**\n     * @brief Bool if agent provides required service ID.\n     *\n     * @param pServiceId The ID of the service to be required.\n     * @return True if the service is provided by agent, false otherwise.\n     */\n    bool providedService(ServiceId_t pServiceId);\n\n    /**\n     * @brief Returns a pointer to the top message in the outbox.\n     *\n     * @return Pointer to the top message in the outbox.\n     */\n    Message* getTopOutboxMessage();\n\n    /**\n    * @brief Registers the agent as a child of the specified parent agent.\n    *\n    * @param pParent Pointer to the parent agent.\n    */\n    void registerAsChild(Agent* pParent);\n\n    /**\n     * @brief Registers the specified agent as a child of the current agent.\n     *\n     * @param pChild Pointer to the agent to be registered as a child.\n     */\n    void registerChild(Agent* pChild);\n\n    /**\n     * @brief Unregisters this agent as a child from its parent.\n     */\n    void unregisterAsChild();\n\n    /**\n     * @brief Unregisters a child agent with the specified ID.\n     *\n     * @param pChildId The ID of the child agent to unregister.\n     */\n    void unregisterChild(AgentId_t pChildId);\n\n    /**\n    * @brief Gets the pointer the agent's parent.\n    *\n    * @return The pointer to agent's parent.\n    */\n    Agent* getParent();\n\n    /**\n    * @brief Set the agent's parent.\n    *\n    * @param pPrent Pointer to new agent's parent.\n    */\n    void setParent(Agent* pPrent);\n\n    /**\n     * @brief Retrieves the ID of the agent providing the specified service.\n     *\n     * The service can provides current agent or some of his childs.\n     *\n     * @param pServiceId The ID of the service to check.\n     * @param pSenderId The ID of the message sender.\n     * @return The ID of the agent providing the service, or -1 if no agent provides the service.\n     */\n    AgentId_t getAgentIdProvidedService(ServiceId_t pServiceId, AgentId_t pSenderId);\n\n    /**\n     * @brief Checks if a child agent with the specified ID exists.\n     *\n     * @param pChildId The ID of the child agent to check.\n     * @return True if a child agent with the specified ID exists, otherwise false.\n     */\n    bool childExists(AgentId_t pChildId);\n\n    /**\n     * @brief Agent initialization.\n     *\n     * Method registers all agent functions, etc.\n     */\n    void initialization();\n\n    /**\n     * @brief Function for registration of Petri Net.\n     * @param registeredPetriNet    petri net\n     */\n    void registerPetriNet(PetriNet* registeredPetriNet);\n    \n    /**\n    * @brief Registers functions for handling events.\n    *\n    * This method must be implemented by derived classes.\n    */\n    virtual void registerFunctions() = 0;\n};",
    "Message" : "#pragma once\n\n#include \"types.h\"\n\n/**\n * @brief Definition of the Message structure.\n *\n * This structure represents a message that can be sent between agents.\n */\nstruct Message {\n    static int nextMessageId;\n    int messageId; /**< Unique identifier for the message */\n    SimTime_t execTime; /**< Execution time of the message */\n    int priority; /**< Priority of the message */\n    AgentId_t sender; /**< ID of the sender agent */\n    AgentId_t receiver; /**< ID of the receiver agent */\n    ServiceId_t serviceId; /**< ID of the service */\n\n    /**\n     * @brief Overloaded greater-than operator for comparing messages.\n     *\n     * This operator compares two messages based on their execution times and priorities.\n     * If the execution times are equal, it compares their priorities.\n     *\n     * @param other The message to compare with.\n     * @return true if the current message has a greater execution time or if the execution times are equal and the priority is higher; false otherwise.\n     */\n    bool operator<(const Message& other) const;\n\n    /**\n     * @brief Constructor for the Message structure.\n     *\n     * This constructor initializes a Message object with custom values.\n     *\n     * @param pExecTime The execution time of the message.\n     * @param pPriority The priority of the message.\n     * @param pSdr The ID of the sender agent.\n     * @param pRcvr The ID of the receiver agent. */\n    Message(SimTime_t pExecTime, int pPriority, ServiceId_t pServiceId, AgentId_t pSdr, AgentId_t pRcvr);\n};\n\n// Define a custom comparison functor\nstruct MessagePtrComparator {\n    bool operator()(const Message* m1, const Message* m2) const;\n};",
    "PetriNet" : "#pragma once\n\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <algorithm>\n\n#include \"types.h\"\n\n/**\n * @brief The PetriNet class represents a Petri net.\n */\nclass PetriNet {\nprivate:\n    std::unique_ptr<std::vector<ServiceId_t>> serviceIds; /**< Unique pointer to a vector of service IDs. */\npublic:\n    /**\n     * @brief Constructs a PetriNet object.\n     */\n    PetriNet();\n\n    /**\n    * @brief Retrieves the execution function associated with a service ID.\n    *\n    * @param pServiceId The service ID.\n    * @return The execution function associated with the service ID.\n    */\n    ExecFunct_t getExecFunct(ServiceId_t pServiceId);\n\n    /**\n    * @brief Checks if a service is provided.\n    *\n    * @param pServiceId The service ID to check.\n    * @return True if the service is provided, false otherwise.\n    */\n    bool providedService(ServiceId_t pServiceId);\n};",
    "Schedule" : "#pragma once\n\n#include <iostream>\n#include <vector>\n#include <queue>\n\n#include \"message.h\"\n\n/**\n * @brief The Schedule class represents a schedule for storing and managing scheduled messages.\n */\nclass Schedule {\nprivate:\n    static const SimTime_t SIMULATION_TIME_OFFSET;\n    /**\n     * @brief priorityQueue is a priority queue to store pointers to Message objects.\n     * The messages are ordered based on their scheduled execution time and priority.\n     */\n    std::priority_queue<Message*, std::vector<Message*>, MessagePtrComparator> priorityQueue;\n\npublic:\n    /**\n     * @brief Pushes a message pointer into the schedule.\n     *\n     * @param pMsg Pointer to the Message object to be pushed.\n     */\n    void pushMessage(Message* pMsg);\n\n    /**\n     * @brief Pops the top message pointer from the schedule.\n     *\n     * @param pTime Simulation time to check for scheduled messages.\n     * @param pOffset Offet for simulation time until we can performed all messages (optional, default is const)\n     * @return Pointer to the top Message object, or nullptr if no message is scheduled at pTime.\n     */\n    Message* popMessage(SimTime_t currTime, SimTime_t pOffset = SIMULATION_TIME_OFFSET);\n\n    /**\n     * @brief Pops the top message pointer from the schedule.\n     *\n     * @return Pointer to the top Message object, or nullptr if no message is scheduled at pTime.\n     */\n    Message* popMessage();\n};\n",
    "SimulationCore" : "#pragma once\n\n#include <unordered_map>\n\n#include \"agent.h\"\n#include \"message.h\"\n#include \"types.h\"\n\n/**\n * @brief Represents the core of a simulation.\n *\n * This class manages the execution of the simulation and interaction\n * between different agents.\n */\nclass SimulationCore : public Agent{\nprivate:\n    SimTime_t currTime; /**< Current simulation time. */\n    SimTime_t endTime; /**< End time of the simulation. */\n    std::unordered_map<AgentId_t, Agent*> agents; /**< Map of agent IDs to agent objects. */\n    std::unique_ptr<Schedule> mainSchedule; /**< Unique pointer to the main schedule. */\n\npublic:\n    /**\n     * @brief Constructs a new SimulationCore object.\n     *\n     * @param pStartTime The start time of the simulation.\n     * @param pEndTime The end time of the simulation.\n     */\n    SimulationCore(SimTime_t pStartTime, SimTime_t pEndTime);\n\n    /**\n     * @brief Registers an agent with the simulation core.\n     *\n     * The registration of an agent as a parent-child is done when the agent is created.\n     * Do agent initialization (functions registration etc.)\n     *\n     * @param pAgent Pointer to the agent to be registered.\n     */\n    void registerAgent(Agent* pAgent);\n\n    /**\n     * @brief Unregisters an agent from the simulation core.\n     *\n     * @param pAgentId The ID of the agent to be unregistered.\n     */\n    void unregisterAgent(int pAgentId);\n\n    /**\n     * @brief Runs the simulation.\n     *\n     * This function executes the simulation until the end time is reached.\n     */\n    void runSimulation();\n\n    /**\n     * @brief Push messsage to simulation core schedule.\n     * @param pMessage Pushed message.\n     */\n    void pushToMainSchedule(Message* pMessage);\n\nprivate:\n    /**\n    * @brief Registers functions required by offered services.\n    *\n    * This function overrides the registerFunctions() method of the base class.\n    * New function has to be added as lambda function.\n    */\n    void registerFunctions() override;\n\n    /**\n     * @brief Initializes the simulation.\n     *\n     * This function performs initialization tasks before starting the simulation.\n     */\n    void initSimulation();\n\n    /**\n    * @brief Receives messages from agents.\n    *\n    * This function receives messages from all registered agents and processes them.\n    *\n    * @param agent Pointer to the agent from which messages are received.\n    */\n    void receiveAgentMessages(Agent* agent);\n\n    /**\n     * @brief Checks if an agent with the specified ID exists in the simulation core.\n     *\n     * @param pAgentId The ID of the agent to check for existence.\n     * @return true if an agent with the specified ID exists, false otherwise.\n     */\n    bool agentExists(AgentId_t pAgentId);\n\n    /**\n     * @brief Adds a receiver for the message.\n     *\n     * @param pMessage Pointer to the message being received.\n     */\n    void addReceiver(Message* pMessage);\n};\n",
    "Types" : "#pragma once\n#include <functional>\n\nusing AgentId_t = int; // type for agent ID\nusing ServiceId_t = int; // type for service ID\nusing SimTime_t = float; // type for simulation time\nusing ExecFunct_t = std::function<void(int)>; // type for function callback\n\nenum class AgentType {REACTIVE, INTELLIGENT};",
    "AgentTemplate" : "#pragma once\n#include \"../../library/include/agent.h\"\n#include <functional>\n\nclass Agent{}: public Agent {\nprivate:\npublic:\n    Agent{}(Agent* pParent): Agent(pParent) {{}};\n    void registerFunctions() override;\n};"
  },
  "src" : {
    "Agent": "#include \"../include/agent.h\"\n\nAgentId_t Agent::nextAgentId = 1;\n\nvoid Agent::process(ServiceId_t pServiceId, AgentId_t pSender) {\n    if (agentType == AgentType::REACTIVE) {\n        // Find function connected with the entered service ID\n        auto it = functionMap.find(pServiceId);\n        if (it != functionMap.end()) {\n            // Retrieve the function pointer and call it\n            it->second(pSender);\n        } else {\n            // Throw an exception if the function does not exist\n            throw std::runtime_error(\n                    \"Function with service ID \" + std::to_string(pServiceId) + \" does not exist in the map.\");\n        }\n    } else if (agentType == AgentType::INTELLIGENT) {\n        ExecFunct_t funct = petriNet->getExecFunct(pServiceId);\n        funct(pSender);\n    } else {\n        // Throw an exception that agent type is invalid.\n        throw std::runtime_error(\n                \"Agent type is invalid.\");\n    }\n}\n\nSimTime_t Agent::getCurrTime() const {\n    return currTime;\n}\n\nvoid Agent::sendMessage(ServiceId_t pServiceId, SimTime_t pTime, AgentId_t pReceiver, int pPriority) {\n    // Create a new message\n    auto newMessage = new Message{pTime, pPriority, pServiceId, getId(), pReceiver};\n    // Add the new message to the message box\n    outBox->push_back(newMessage);\n}\n\nvoid Agent::registerFunction(ServiceId_t pServiceId, ExecFunct_t pFunc) {\n    // Add the function pointer to the function map\n    functionMap[pServiceId] = std::move(pFunc);\n}\n\nvoid Agent::unregisterFunction(int pServiceId) {\n    // Find the function pointer associated with the event ID\n    auto it = functionMap.find(pServiceId);\n    if (it != functionMap.end()) {\n        // If the function pointer is found, remove it from the map\n        functionMap.erase(it);\n    } else {\n        // If the function with the specified event ID does not exist, throw an exception\n        throw std::runtime_error(\"Function with service ID \" + std::to_string(pServiceId) + \" does not exist in the map\");\n    }\n}\n\nAgent::Agent(Agent* pParent) {\n    id = nextAgentId++;\n    parent = pParent;\n    currTime  = -1;\n    outBox = std::make_unique<std::vector<Message*>>();\n    schedule = std::make_unique<Schedule>();\n    // Register agent as child of his parent.\n    registerAsChild(pParent);\n    agentType = AgentType::REACTIVE;\n    petriNet = nullptr;\n}\n\nvoid Agent::setAgentType(AgentType newAgentType) {\n    agentType = newAgentType;\n}\n\nAgentId_t Agent::getId() const {\n    return id;\n}\n\nvoid Agent::receiveMessage(Message* pMsg) {\n    // Add the received message to the agent's schedule\n    schedule->pushMessage(pMsg);\n}\n\nvoid Agent::execute() {\n    Message* message = schedule->popMessage(); // Get the next scheduled message\n    while (message) { // Loop until there are no more messages scheduled\n        currTime = message->execTime; //Set the current time to the execution time of current message\n        process(message->serviceId, message->sender); // Process the message\n        message = schedule->popMessage(); // Get the next scheduled message\n    }\n}\n\nbool Agent::providedService(ServiceId_t pServiceId) {\n    if (agentType == AgentType::REACTIVE)\n        return functionMap.find(pServiceId) != functionMap.end();\n    else if (agentType == AgentType::INTELLIGENT)\n        return petriNet->providedService(pServiceId);\n}\n\nMessage* Agent::getTopOutboxMessage() {\n    if (outBox->empty()) {\n        return nullptr;\n    }\n    Message* topMessage = outBox->back(); // Get the last message\n    outBox->pop_back(); // Remove the last message\n    return topMessage;\n}\n\nvoid Agent::registerAsChild(Agent* pParent) {\n    // Call the parent's registerChild method to add the current agent to its list of children\n    //Agent of simulation core doesn't have parent.\n    if (!pParent) {\n        return;\n    }\n    pParent->registerChild(this);\n    // Set the parent pointer of the current agent\n    setParent(pParent);\n}\n\nvoid Agent::registerChild(Agent* pChild) {\n    if (childExists(pChild->getId())) {\n        // Throw an exception if the child already exist\n        throw std::runtime_error(\"Agent with ID \" + std::to_string(pChild->getId()) +\n        \" is already registered as child of agent with ID \" + std::to_string(id) + \".\");\n    }\n    childs[pChild->getId()] = pChild;\n}\n\nvoid Agent::unregisterAsChild() {\n    // Simulation core agent doesn't have parent\n    if (!parent) {\n        return;\n    }\n    // Unregister agent from parent child's map.\n    parent->unregisterChild(id);\n    // Set agent's parent to nullptr.\n    parent = nullptr;\n}\n\nvoid Agent::unregisterChild(AgentId_t pChildId) {\n    if (not childExists(pChildId)) {\n        // Throw an exception if the child is not agent's child\n        throw std::runtime_error(\"Agent with ID \" + std::to_string(pChildId) + \" is not child of agent with ID \" + std::to_string(id) + \".\");\n    }\n    // Erase agent from child map\n    childs.erase(pChildId);\n}\n\nAgent* Agent::getParent() {\n    return parent;\n}\n\nvoid Agent::setParent(Agent* pPrent) {\n    parent = pPrent;\n}\n\nAgentId_t Agent::getAgentIdProvidedService(ServiceId_t pServiceId, AgentId_t pSenderId) {\n    if (providedService(pServiceId)) {\n        return id;\n    }\n\n    // Search among the agent's child\n    for (const auto& pair : childs) {\n        Agent* child = pair.second;\n        if (child->getId() == pSenderId) {\n            continue;\n        }\n        if (child->providedService(pServiceId)) {\n            return child->getId();\n        }\n    }\n\n    // Recursively search among the children of each agent\n    for (const auto& pair : childs) {\n        Agent* child = pair.second;\n        if (child->getId() == pSenderId) {\n            continue;\n        }\n        AgentId_t id = child->getAgentIdProvidedService(pServiceId, pSenderId);\n        if (id != -1) {\n            return id;\n        }\n    }\n    return -1;\n}\n\nbool Agent::childExists(AgentId_t pChildId) {\n    return childs.find(pChildId) != childs.end();\n}\n\nvoid Agent::initialization() {\n    // Call all necessary functions for agent initialization\n    registerFunctions();\n}\n\nvoid Agent::registerPetriNet(PetriNet* registeredPetriNet) {\n    petriNet = registeredPetriNet;\n}",
    "Message": "#include \"../include/message.h\"\n\nint Message::nextMessageId = 1;\n\nbool Message::operator<(const Message& other) const {\n    return execTime == other.execTime ? priority < other.priority : execTime > other.execTime;\n}\n\nMessage::Message(SimTime_t pExecTime, int pPriority, ServiceId_t pServiceId, AgentId_t pSdr, AgentId_t pRcvr) {\n    messageId = nextMessageId++;\n    execTime = pExecTime;\n    priority = pPriority;\n    sender = pSdr;\n    receiver = pRcvr;\n    serviceId = pServiceId;\n}\n\nbool MessagePtrComparator::operator()(const Message* m1, const Message* m2) const {\n    //Message m1 has a priority lower than that of message m2 if its execution time is less than that of m2.\n    // If the execution times are equal, then the priority is determined by the message with the lower priority number.\n    return *m1 < *m2;\n}\n",
    "PetriNet": "#include \"../include/petriNet.h\"\n\nPetriNet::PetriNet() {\n    serviceIds = std::make_unique<std::vector<ServiceId_t>>();\n}\n\nExecFunct_t PetriNet::getExecFunct(ServiceId_t pServiceId) {\n    throw std::runtime_error(\n            \"Function hasn't been implemented yet.\");\n}\n\nbool PetriNet::providedService(ServiceId_t pServiceId) {\n    // Searching of the value in the vector\n    return std::find(serviceIds->begin(), serviceIds->end(), pServiceId) == serviceIds->end();\n}",
    "Schedule": "#include \"../include/schedule.h\"\n\nconst SimTime_t Schedule::SIMULATION_TIME_OFFSET = 0;\n\nvoid Schedule::pushMessage(Message* message) {\n    // Pushes a message into the schedule.\n    priorityQueue.push(message);\n}\n\nMessage* Schedule::popMessage(SimTime_t currTime, SimTime_t offset) {\n    if (priorityQueue.empty()) {\n        return nullptr; // Return nullptr if the priority queue is empty\n    }\n    Message* topMessage = priorityQueue.top();\n    if (topMessage->execTime <= currTime + offset) { // Check if the top message's time has elapsed\n        priorityQueue.pop(); // Remove the top message from the priority queue\n        return topMessage;\n    }\n    return nullptr; // Return nullptr if the top message's time hasn't elapsed\n}\n\nMessage* Schedule::popMessage() {\n    if (priorityQueue.empty()) {\n        return nullptr; // Return nullptr if the priority queue is empty\n    }\n    Message* topMessage = priorityQueue.top();\n    priorityQueue.pop(); // Remove the top message from the priority queue\n    return topMessage;\n}",
    "SimulationCore" : "#include <set>\n#include \"../include/simulationCore.h\"\n\n//ID = 1\n//parent = nullptr\nSimulationCore::SimulationCore(SimTime_t pStartTime, SimTime_t pEndTime) : Agent(nullptr) {\n    currTime = pStartTime;\n    endTime = pEndTime;\n    registerAgent(this);\n    mainSchedule = std::make_unique<Schedule>();\n}\n\nvoid SimulationCore::registerAgent(Agent* pAgent) {\n    //Note: The registration of an agent as a parent-child is done when the agent is created.\n    if (!pAgent) {\n        throw std::runtime_error(\"Cannot register agent because the agent is nullptr.\");\n    }\n    // Registers an agent of simulation core based on his unique id\n    agents[pAgent->getId()] = pAgent;\n    // Make agent initialization\n    pAgent->initialization();\n}\n\nvoid SimulationCore::unregisterAgent(int agentId) {\n    // Find the agent with the specified ID in the map\n    if (not agentExists(agentId)) {\n        // If the agent is not found, throw an exception\n        throw std::runtime_error(\"Agent with event ID \" + std::to_string(agentId) + \" does not exist in the map\");\n    }\n    // Unregister agent as child of other agent.\n    agents[agentId]->unregisterAsChild();\n    // Unregister agent from simulation core.\n    agents.erase(agentId);\n}\n\nvoid SimulationCore::runSimulation() {\n    // Initialization\n    initSimulation();\n    //Run\n    // Set to store IDs of agents that received messages\n    std::unique_ptr<std::set<AgentId_t>> receivedAgentIds = std::make_unique<std::set<AgentId_t>>();\n    // Get the next scheduled message\n    Message* message = mainSchedule->popMessage(); // Get the next scheduled message\n    // Loop until there are no more messages scheduled for the current time\n    while (message) {\n        currTime = message->execTime;\n        while (message) {\n            // Check if the receiver agent exists\n            if (not agentExists(message->receiver)) {\n                throw std::runtime_error(\"No agent is registered under ID \" + std::to_string(message->receiver) + \".\");\n            }\n            // Insert the receiver ID into the set\n            receivedAgentIds->insert(message->receiver);\n            // Retrieve the receiver agent and deliver the message\n            Agent *agent = agents[message->receiver];\n            agent->receiveMessage(message);\n            // Get the next scheduled message for the current time\n            message = mainSchedule->popMessage(currTime);\n        }\n\n        // Execute agents that received messages and process their outbound messages\n        for (AgentId_t id: *receivedAgentIds) {\n            Agent *agent = agents[id];\n            agent->execute();\n            receiveAgentMessages(agent);\n        }\n        // Clean the set.\n        receivedAgentIds->clear();\n\n        // Get the next scheduled message\n        message = mainSchedule->popMessage();\n    }\n}\n\nvoid SimulationCore::pushToMainSchedule(Message* pMessage) {\n    if (!pMessage) {\n        throw std::runtime_error(\"The received message is nullptr.\");\n    }\n    // Add receiver of message if he is missing\n    if (pMessage->receiver == -1) {\n        addReceiver(pMessage);\n    }\n    // Push message to simulation core schedule.\n    mainSchedule->pushMessage(pMessage);\n}\n\nvoid SimulationCore::registerFunctions() {\n    // Register a lambda function to handle function\n    registerFunction(1, [this](int sender) {\n        allDone(sender);\n    });\n}\n\nvoid SimulationCore::initSimulation() {\n    // empty\n}\n\nvoid SimulationCore::receiveAgentMessages(Agent* agent) {\n    // Retrieve the top message of the agent's outbox\n    Message* message = agent->getTopOutboxMessage();\n    // Process all messages of the agent's outbox\n    while (message) {\n        Agent* receiver;\n        // If the receiver ID is not specified, find the closest agent that accepts the service\n        if (message->receiver == -1) {\n            addReceiver(message);\n        }\n        // Schedule the message for the receiver to the main schedule\n        mainSchedule->pushMessage(message);\n        // Get the next message of the agent\n        message = agent->getTopOutboxMessage();\n    }\n}\n\nbool SimulationCore::agentExists(AgentId_t pAgentId) {\n    return agents.find(pAgentId) != agents.end();\n}\n\nvoid SimulationCore::addReceiver(Message* pMessage) {\n    Agent* sender = agents[pMessage->sender];\n    AgentId_t receiverId = -1;\n    do {\n        // Search for an agent ID providing the required service\n        receiverId = sender->getAgentIdProvidedService(pMessage->serviceId, sender->getId());\n        sender = sender->getParent();\n        if (sender == nullptr)\n            break;\n    } while (receiverId == -1);\n\n    if (receiverId == -1) {\n        // If no agent provides the service, throw an error\n        throw std::runtime_error(\"No service registered under ID \" + std::to_string(pMessage->serviceId) + \".\");\n    }\n    // Assign the receiver ID to the message\n    pMessage->receiver = receiverId;\n}\n}",
    "AgentTemplate" : "#include \"agent{}.h\"\n\nvoid Agent{}::registerFunctions() {{\n}}"
  },
  "template" : {
    "Attribute" : "{} {};",
    "FunctionDef" : "void {}(int pSender);",
    "FunctionImpl" : "void Agent{}::{}(int pSender) {{\n    //add your code\n    }}",
    "FunctionReg" : "registerFunction({}, [this](int pSender) {{\n        {}(pSender);\n    }});"
  }
}